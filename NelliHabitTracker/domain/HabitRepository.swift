//
//  HabitRepository.swift
//  NelliHabitTracker
//
//  Created by Bagyura Istvan on 2020. 12. 14..
//

import Foundation
import Combine
import Bow


import CouchbaseLiteSwift



enum RepositoryError: Error {
    case nonUnique
}

class HabitRepository {
    static var shared = HabitRepository()
    // TODO: should be only one and shared?
    var database: Database
    init() {
        do {
            database = try Database(name: "oaths-db")
//            try database.delete()
//            database = try Database(name: "oaths-db")
            
        } catch {
            fatalError("Error opening database.")
        }
    }
    
   // TODO create a class
    private func dictionaryToHabit(record: CouchbaseLiteSwift.Result ) -> Habit {
        let businessProperties = record.dictionary(forKey: "oaths-db")
        let id = UUID(uuidString: record.string(forKey: "id")!)! // It must exist
        let name = (businessProperties?.string(forKey: "name")).or("Unknown")
        let createdAt = (businessProperties?.date(forKey: "createdAt")).or(Date())
        let doneDates = ((businessProperties?.array(forKey: "doneDates")?.toArray() as? [Int]) ?? [Int]())
                                                .map { TimeInterval($0) }
                                                .map { Date(timeIntervalSince1970: $0) }
        
        return Habit(id: id,
                     name: name,
                     createdAt: createdAt,
                     doneDates: doneDates)
        
        
    }
    
    func all() -> AnyPublisher<[Habit],Never> {
        let query = QueryBuilder
            .select(SelectResult.all(),
                    SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("Habit")))

        return Just(query)
                    .map { query in
//                        return Try
//                            .invoke { try query.execute() }
//                            .map { $0.allResults }
//                            .getOrElse([MutableDocument]())
//                        let tryFromThrow = Try.invoke { try validateThrow(email: "wrong_email.com") }
                        
                        do {
                            return try query.execute()
                                        .allResults()
//                                        .compactMap { $0.dictionary(forKey: "oaths-db") } // return only non-nils
//                                        .map { Habit(name: $0.string(forKey: "name").or("Unknown")) }
                                .map { dictionaryToHabit(record: $0) }
                            
//                        var habits = [Habit]()
//                            for record in resultSet {
//
//                                /*
//                                 guard let dict = result.dictionary(forKey: databaseName),
//                                       let name = dict.string(forKey: PizzaKeys.name.rawValue),
//                                       let id = result.string(forKey: PizzaKeys.id.rawValue) else {
//                                         continue
//                                       }
//
//                                       let pizza = Pizza(id: id, name: name,
//                                                         price: dict.double(forKey: PizzaKeys.price.rawValue))
//                                       menu.append(pizza)
//                                     }
//
//
//                                 // Update a document.
//                                 if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
//                                     mutableDoc.setString("Swift", forKey: "language")
//                                     do {
//                                         try database.saveDocument(mutableDoc)
//
//                                         let document = database.document(withID: mutableDoc.id)!
//                                         // Log the document ID (generated by the database)
//                                         // and properties
//                                         print("Document ID :: \(document.id)")
//                                         print("Learning \(document.string(forKey: "language")!)")
//                                     } catch {
//                                         fatalError("Error updating document")
//                                     }
//                                 }
//
//                                 */
//
//                                if let dictionary = record.dictionary(forKey: "oaths-db") {
//                                    habits.append(Habit(name:dictionary.string(forKey: "name").or("Unknown")))
//                                }
//                            }
//
//                            return habits
                        } catch {
                            fatalError("Error running the query")
                        }
                        
                    }.eraseToAnyPublisher()
        
    }
    
    // TODO: merge() add and update()
    func update(_ habit: Habit) {
        if let mutableDoc = database.document(withID: habit.id.uuidString)?.toMutable() {
            mutableDoc
                .setString(habit.name, forKey: "name")
                .setString("Habit", forKey: "type")
                .setArray( MutableArrayObject(data: habit.doneDates.map{Int($0.timeIntervalSince1970)}), forKey: "doneDates")
            do {
                try database.saveDocument(mutableDoc)
            } catch {
                fatalError("Error updating document")
            }
        }
    }
    
    
    
    func add(_ habit: Habit) {
        let mutableDoc = MutableDocument(id: habit.id.uuidString)
            .setString(habit.name, forKey: "name")
            .setString("Habit", forKey: "type")
            .setDate(Date(), forKey: "createdAt")
            .setArray( MutableArrayObject(data: habit.doneDates.map{Int($0.timeIntervalSince1970)}), forKey: "doneDates")
        
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }
    }
    
    /*
     if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
     //                                     mutableDoc.setString("Swift", forKey: "language")
     //                                     do {
     //                                         try database.saveDocument(mutableDoc)
     //
     //                                         let document = database.document(withID: mutableDoc.id)!
     //                                         // Log the document ID (generated by the database)
     //                                         // and properties
     //                                         print("Document ID :: \(document.id)")
     //                                         print("Learning \(document.string(forKey: "language")!)")
     //                                     } catch {
     //                                         fatalError("Error updating document")
     //                                     }
     //                                 }
     */
    
    // TODO: remove fatalerrors and do a proper error handling
    func delete(_ habit: Habit) {
        do {
            if let document = database.document(withID: habit.id.uuidString) {
                try database.deleteDocument(document)
            }
        } catch {
            fatalError("Error deleing document")
        }
    }
    
//    func all() -> AnyPublisher<[Habit],Never> {
//        return Just(habits)
//                .eraseToAnyPublisher()
//    }
//
//    func save(habit: Habit) -> AnyPublisher<Bool,Never> {
//        Just(habit)
//            .map{ habits.append($0); return true }
//            .eraseToAnyPublisher()
//
//    }
    
    
    /*
     func userNameAvailable(_ username: String) -> AnyPublisher<Validated<SignUpError,String>,Never> {
         /*
         func usernameAvailable(_ username: String, completion: @escaping (Bool) -> ()) -> () {
           DispatchQueue.main .async {
             if (username == "foobar") {
               completion(true)
             } else {
               completion(false)
             }
           }
         }
         */
         
         let validatedUserName = username == "oriaxx77" ? Validated.valid(username) : Validated.invalid(SignUpError.usernameNotAvailable)
         print("Validating user name: \(username) \(validatedUserName)")
         return Just(validatedUserName).eraseToAnyPublisher()
     }
     */

    
}

